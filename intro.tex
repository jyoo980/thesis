%% The following is a directive for TeXShop to indicate the main file
%%!TEX root = diss.tex

% TODO: update this as required (until the cutoff date).
\newcommand{\numparticipants}{69}
% TODO: please remember to update this before I submit to GPS.
\newcommand{\userstudynum}{75}
\newcommand{\fasterpct}{64}
\newcommand{\usefulpct}{70}

\chapter{Introduction}
\label{ch:Introduction}

\begin{epigraph}
    \emph{
       A human must turn information into intelligence or knowledge. \\
       We've tended to forget that no computer will ever ask a new question.
     } ---~Rear Admiral Grace M. Hopper
\end{epigraph}

\noindent It has never been easier for software developers to write programs.
There are a plethora of tools that have evolved over the years with the singular
goal of making it easier for developers to write code.
Code-completion tools building on context-dependent program analysis 
\cite{reps-1983-context} enable developers to work in unfamiliar systems and
software projects.
Many modern \acp{IDE} are capable of generating
a large amount of boilerplate code at the click of a mouse.
Recent work in large language models and deep learning \cite{chen-2021-copilot}
has given rise to tools that developers can use to generate entire method 
implementations.
These tools are able to present an incredible amount of information, and these 
are only a few in the toolbox of the modern software developer.

\par However, developers engage in a wide variety of tasks;
writing code is only part of their diverse workflows 
\cite{meyer-2017-work-life}.
Developers also analyze requirements and problems, and map out broad flows of
code that may be used to solve a problem.
They also spend a large amount of time attempting to understand code.
This may include activities such as reasoning about the inputs and outputs of
a method, sketching out what the call stack looks like, and even asking 
\emph{why} the code is doing what it is doing \cite{latoza-2006-mental-models}.
A study by Ko \etal{} found that developers spent approximately 22\% of their
time reading code, while a further 16\% was spent on navigating dependencies.
\cite{ko-2005-eliciting-design}.
This equates to developers spending approximately 38\% of their time on
program comprehension tasks, in comparison to spending approximately 20\% of
their time on editing code \cite{ko-2005-eliciting-design}.

\par The questions that developers may ask themselves as they attempt to 
understand and modify code are often difficult to answer. 
The difficulty of these questions even appear to be unrelated to how much
professional experience a developer has, or their familiarity with a codebase
\cite{latoza-2010-reach}.
Questions that developers frequently report as being challenging to answer are
often related to the intent and implementation of code, or associated with 
debugging tasks \cite{latoza-2010-hard-questions}.
\par To effectively debug their systems and accurately reason about the
intent and implementation of their code, developers must trace through
through vast swathes of control-flow paths and filter for task-relevant 
information.
This process of searching through the feasible paths and control-flow of a
program for a set of target statements matching some search criteria can be
formalized as the answering of \emph{reachability questions}
\cite{latoza-2010-reach}.
For example, a developer may ask ``where did some argument \texttt{a} for a 
method \texttt{m} come from?"
This question could be translated to a reachability question that queries the
program for the set of feasible control-flow paths that terminate at the
method \texttt{m}, filtering for statements that include dependencies for
the argument \texttt{a}.

\par Tools such as the \emph{Whyline} can help developers reason about
reachability questions by enabling developers to conduct retrospective
debugging sessions of their programs \cite{ko-2004-whyline}.
The Whyline requires developers to run a program to collect an execution 
history.
It then conducts an offline dynamic analysis on the execution history to 
generate the information required for a retroactive debugging session.
Using the Whyline, developers are able to inspect a preset collection of 
question-and-answer pairs about the state of their programs that they may use 
to help answer reachability questions.
The Whyline exists as a separate tool that is complementary to a developer's
existing \ac{IDE}, which may help in enforcing a separation of concerns between
a development environment and a purpose-built program comprehension tool.
However, this introduces the question of how best to display program 
information in a useful \emph{and} usable manner; creating a separate 
environment that may present information in an unfamiliar context may have 
unintended effects on a developer's cognitive load.

\emph{GetMeHere} developed by Microsoft Research attempts to help developers 
answer reachability questions by translating them into verification problems
that are dispatched to an \ac{SMT} solver \cite{barnett-2014-get}.
Similarly to the Whyline, GetMeHere performs an analysis on runtime information
in the form of a program execution trace.
However, the developer does not need to explicitly run a program or parts of a 
program to collect an execution trace; GetMeHere automatically generates an 
execution trace, including any relevant input necessary to reach those parts of 
code \cite{barnett-2014-get}.
GetMeHere also enables developers to form reachability questions that are more
general in scope, mitigating the limitations associated with constraining
the set of possible reachability questions.
Unlike the Whyline, GetMeHere is not built as a standalone tool, but is
integrated into existing \ac{IDE}, namely Microsoft Visual Studio.
Although the performance of GetMeHere on smaller benchmark programs (\eg 
650 - $11,000$ LOC) is promising, it has yet to be evaluated on programs that 
are more representative of production software systems today.
Although GetMeHere is integrated into an existing \ac{IDE}, it presents program
information in a visualization that is based on the Code Bubbles paradigm
\cite{barnett-2014-get, bragdon-2010-code-bubbles}.
This gives rise to the same question presented by how the Whyline presents
information to a developer; the effects of presenting program information in
an unfamiliar visual paradigm are not well-understood.

\par It is clear that developers have tools at their disposal that aid them in
answering reachability questions; both Whyline and GetMeHere provide incredible 
amounts of information for developers.
However, it is unclear whether this information is presented in a usable
manner, and what effects it may have on the problem of information overload.

\par In this thesis, I begin by exploring the reachability questions that
developers ask in practice by analyzing the results of a survey answered
by \numparticipants{} professional software developers.
To ensure the questions asked in the survey were reflective of real-world
developer questions, many were selected them from a previous study on 
reachability questions from LaToza \etal{} \cite{latoza-2010-reach} and from an
investigation of questions that developers found challenging to answer
\cite{latoza-2010-hard-questions}.
Each question included a code excerpt and a reachability question that a
developer may encounter during their day-to-day work.
Developers were asked to rank each reachability question on the frequency with 
which they encountered them in their work.

\par The survey results provided an empirically-supported foundation for the
development of \emph{\toolname{}}, a plugin for the JetBrains IntelliJ Platform 
that enables developers to answer popular reachability questions on-the-fly.
To evaluate \toolname{}, we considered two research questions:

\begin{itemize}
  \item[] \textbf{RQ1:} What is the effect of \toolname{} on a developer's 
  cognitive load as they analyze a system to answer reachability questions?
  \item[] \textbf{RQ2:} Does \toolname{} have an effect on the completeness
  of the analysis by a developer as they use it to help answer reachability 
  questions?
\end{itemize}

% TODO: write about results properly

We explored these research questions by conducting a user study of \toolname{}
with \userstudynum{} professional software developers.
Using \toolname{}, developers in our study were able to obtain answers to 
reachability questions approximately \fasterpct{}\% faster than the control 
group.
Most participants in our study also found \toolname{} useful, with 
\usefulpct{}\% of them reporting that they would use the tool if it was
available.

\par This thesis makes the following contributions:

\begin{itemize}
  \item Provides empirical evidence in support of the type and frequency of
        reachability questions previously investigated by LaToza \etal{}
        \cite{latoza-2010-reach}.
  \item Introduces \toolname, a plugin for the JetBrains IntelliJ Platform that 
        presents an interface that developers may use to effectively answer 
        reachability questions that occur in high frequency.
\end{itemize}

A study of the questions that software developers ask in practice, tools that
support developer questions, and how developers currently explore and 
answer questions about their programs is explored in Chapter 
\ref{ch:RelatedWork}. In Chapter \ref{ch:Survey}, we detail the method, 
results, and threats to validity of the survey used to analyze the type and 
frequency of reachability questions that professional developers ask in 
practice. we describe the implementation of \toolname{} in Chapter 4, and discuss
the user study and evaluation of the tool in Chapter 5.
Finally, we conclude with a summary of the work in Chapter 6 and describe future
work and research directions.

\endinput
